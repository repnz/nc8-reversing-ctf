jump 0x110
0x100 0xe0 push [+2]
0x101 0xfe pop pc

# 0x110 address
0x102 0x01 int 0x1
0x103 0x10 mov r0, 0

# after the FLAG :)
0x104 0xc4 jmp +6
0x105 0x2a mov [r2], r2
0x106 0x13 mov r0, -1
0x107 0x37 mov r1, [r3]

# 0x104
0x108 0x01 int 0x1
0x109 0x04 int 0x4

# 0x17d
0x10a 0x01 int 0x1
0x10b 0x7d '}'

# 0x7d
0x10c 0x00 int 0x0
0x10d 0x7d '}'

# 0x147
0x10e 0x01 int 0x1
0x10f 0x47 add r1, r3

>> Jump after unpacked code
0x110 0xe8 push [-8] # 0x104
0x111 0xe9 push [-7] # 0x17d
0x112 0xea push [-6] # 0x7d
0x113 0xeb push [-5] # 0x147
0x114 0xfe pop pc

# Booting stage 1 its only the beginning
0x115 0x42 add r0, r2
0x116 0x4f add r3, r3
0x117 0x4f add r3, r3
0x118 0x54 xor r1, r0
0x119 0x49 add r2, r1
0x11a 0x4e add r3, r2
0x11b 0x47 add r1, r3
0x11c 0x20 mov [r0], r0
0x11d 0x53 xor r0, r3
0x11e 0x54 xor r1, r0
0x11f 0x41 add r0, r1
0x120 0x47 add r1, r3
0x121 0x45 add r1, r1
0x122 0x31 mov r0, [r1]
0x123 0x3a mov r2, [r2]
0x124 0x20 mov [r0], r0
0x125 0x46 add r1, r2
0x126 0x4c add r3, r0
0x127 0x41 add r0, r1
0x128 0x47 add r1, r3
0x129 0x2d mov [r3], r1
0x12a 0x54 xor r1, r0
0x12b 0x68 'h'
0x12c 0x31 mov r0, [r1]
0x12d 0x73 's'
0x12e 0x31 mov r0, [r1]
0x12f 0x73 's'
0x130 0x30 mov r0, [r0]
0x131 0x6e 'n'
0x132 0x6c 'l'
0x133 0x79 'y'
0x134 0x54 xor r1, r0
0x135 0x68 'h'
0x136 0x33 mov r0, [r3]
0x137 0x42 add r0, r2
0x138 0x65 'e'
0x139 0x67 'g'
0x13a 0x6c 'l'
0x13b 0x6e 'n'
0x13c 0x6e 'n'
0x13d 0x69 'i'
0x13e 0x6e 'n'
0x13f 0x67 'g'
0x140 0x0a int 0xa

# 0x2c
0x141 0x00 int 0x0
0x142 0x2c mov [r3], r0

# 0x115
0x143 0x01 int 0x1
0x144 0x15 mov r1, 1

# 0xeb
0x145 0x00 int 0x0
0x146 0xeb push [-5]


>> Come here. 
0x147 0xea push [-6] # 0x2c  # length of str
0x148 0xeb push [-5] # 0x115 booting stage 1
0x149 0xec push [-4] # 0xeb  write
0x14a 0xfe pop pc    # write('booting stage 1');
0x14b 0xc5 jmp +7


# 0x0004
0x14c 0x00 int 0x0
0x14d 0x04 int 0x4

# 0x17d
0x14e 0x01 int 0x1
0x14f 0x7d '}'

# 0xfd
0x150 0x00 int 0x0
0x151 0xfd pop r13


0x152 0xea push [-6]  # 0x4
0x153 0xdc push r12   # 0x8
0x154 0xec push [-4]  # 0xfd
0x155 0xe9 push [-7]  # 0x17d
0x156 0xe1 push [+3]  # 0x15b
0x157 0xfe pop pc     # call 0x15b
0x158 0xfe pop pc     # then call 0x17d after decoding

# 0x15b 
0x159 0x01 int 0x1
0x15a 0x5b xor r2, r3





# void some3(0x17d, 0xfd, 0x8, 0x4)
0x15b 0xf4 pop r4 # 0x17d
0x15c 0xf5 pop r5 # 0xfd
0x15d 0xf6 pop r6 # 0x8
0x15e 0xf7 pop r7 # 0x4
0x15f 0xdd push r13
0x160 0x5f xor r3, r3

# loop condition i = r3 loop 0xfd iterations
0x161 0xd5 push r5
0x162 0xf0 pop r0
0x163 0x53 xor r0, r3 # if r3 == r5: exit func
0x164 0xa0 jz +2
0x165 0xc0 jmp +2
0x166 0xfe pop pc

# loop body
0x167 0xd6 push r6
0x168 0xf0 pop r0 
0x169 0xd7 push r7
0x16a 0xf1 pop r1
0x16b 0xd3 push r3
0x16c 0xf2 pop r2
# r0 = 0x8, r1 = 0x4, r2 = i

0x16d 0x99 div r2, r1 # r1 = r2 % r1
0x16e 0x41 add r0, r1   # index to the FLAG... input
0x16f 0x30 mov r0, [r0]
0x170 0xd4 push r4
0x171 0xf1 pop r1 # 0x17d
0x172 0x47 add r1, r3 # index the 0x17d mem with i
0x173 0x39 mov r2, [r1]
0x174 0x48 add r2, r0  # mem[0x17d+i] += input[i % len(input)]
0x175 0x26 mov [r1], r2
0x176 0xc1 jmp +3

# 0x161 address 
0x177 0x01 int 0x1
0x178 0x61 'a'

# loop increment 
0x179 0x11 mov r0, 1
0x17a 0x4c add r3, r0
0x17b 0xec push [-4]
0x17c 0xfe pop pc